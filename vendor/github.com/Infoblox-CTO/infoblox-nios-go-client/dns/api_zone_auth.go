/*
Infoblox DNS API

OpenAPI specification for Infoblox NIOS WAPI DNS objects

API version: 2.13.6
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package dns

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/Infoblox-CTO/infoblox-nios-go-client/internal"
)

type ZoneAuthAPI interface {
	/*
		Get Retrieve zone_auth objects

		Returns a list of zone_auth objects matching the search criteria

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ZoneAuthAPIGetRequest
	*/
	Get(ctx context.Context) ZoneAuthAPIGetRequest

	// GetExecute executes the request
	//  @return ListZoneAuthResponse
	GetExecute(r ZoneAuthAPIGetRequest) (*ListZoneAuthResponse, *http.Response, error)
	/*
		Post Create a zone_auth object

		Creates a new zone_auth object

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ZoneAuthAPIPostRequest
	*/
	Post(ctx context.Context) ZoneAuthAPIPostRequest

	// PostExecute executes the request
	//  @return CreateZoneAuthResponse
	PostExecute(r ZoneAuthAPIPostRequest) (*CreateZoneAuthResponse, *http.Response, error)
	/*
		ReferenceDelete Delete a zone_auth object

		Deletes a specific zone_auth object by reference

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param reference Reference of the zone_auth object
		@return ZoneAuthAPIReferenceDeleteRequest
	*/
	ReferenceDelete(ctx context.Context, reference string) ZoneAuthAPIReferenceDeleteRequest

	// ReferenceDeleteExecute executes the request
	ReferenceDeleteExecute(r ZoneAuthAPIReferenceDeleteRequest) (*http.Response, error)
	/*
		ReferenceGet Get a specific zone_auth object

		Returns a specific zone_auth object by reference

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param reference Reference of the zone_auth object
		@return ZoneAuthAPIReferenceGetRequest
	*/
	ReferenceGet(ctx context.Context, reference string) ZoneAuthAPIReferenceGetRequest

	// ReferenceGetExecute executes the request
	//  @return GetZoneAuthResponse
	ReferenceGetExecute(r ZoneAuthAPIReferenceGetRequest) (*GetZoneAuthResponse, *http.Response, error)
	/*
		ReferencePut Update a zone_auth object

		Updates a specific zone_auth object by reference

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param reference Reference of the zone_auth object
		@return ZoneAuthAPIReferencePutRequest
	*/
	ReferencePut(ctx context.Context, reference string) ZoneAuthAPIReferencePutRequest

	// ReferencePutExecute executes the request
	//  @return UpdateZoneAuthResponse
	ReferencePutExecute(r ZoneAuthAPIReferencePutRequest) (*UpdateZoneAuthResponse, *http.Response, error)
}

// ZoneAuthAPIService ZoneAuthAPI service
type ZoneAuthAPIService internal.Service

type ZoneAuthAPIGetRequest struct {
	ctx            context.Context
	ApiService     ZoneAuthAPI
	returnFields   *string
	returnFields2  *string
	maxResults     *int32
	returnAsObject *int32
	paging         *int32
	pageId         *string
	filters        *map[string]interface{}
	extattrfilter  *map[string]interface{}
}

// Enter the field names followed by comma
func (r ZoneAuthAPIGetRequest) ReturnFields(returnFields string) ZoneAuthAPIGetRequest {
	r.returnFields = &returnFields
	return r
}

// Enter the field names followed by comma, this returns the required fields along with the default fields
func (r ZoneAuthAPIGetRequest) ReturnFields2(returnFields2 string) ZoneAuthAPIGetRequest {
	r.returnFields2 = &returnFields2
	return r
}

// Enter the number of results to be fetched
func (r ZoneAuthAPIGetRequest) MaxResults(maxResults int32) ZoneAuthAPIGetRequest {
	r.maxResults = &maxResults
	return r
}

// Select 1 if result is required as an object
func (r ZoneAuthAPIGetRequest) ReturnAsObject(returnAsObject int32) ZoneAuthAPIGetRequest {
	r.returnAsObject = &returnAsObject
	return r
}

// Control paging of results
func (r ZoneAuthAPIGetRequest) Paging(paging int32) ZoneAuthAPIGetRequest {
	r.paging = &paging
	return r
}

// Page id for retrieving next page of results
func (r ZoneAuthAPIGetRequest) PageId(pageId string) ZoneAuthAPIGetRequest {
	r.pageId = &pageId
	return r
}

func (r ZoneAuthAPIGetRequest) Filters(filters map[string]interface{}) ZoneAuthAPIGetRequest {
	r.filters = &filters
	return r
}

func (r ZoneAuthAPIGetRequest) Extattrfilter(extattrfilter map[string]interface{}) ZoneAuthAPIGetRequest {
	r.extattrfilter = &extattrfilter
	return r
}

func (r ZoneAuthAPIGetRequest) Execute() (*ListZoneAuthResponse, *http.Response, error) {
	return r.ApiService.GetExecute(r)
}

/*
Get Retrieve zone_auth objects

Returns a list of zone_auth objects matching the search criteria

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ZoneAuthAPIGetRequest
*/
func (a *ZoneAuthAPIService) Get(ctx context.Context) ZoneAuthAPIGetRequest {
	return ZoneAuthAPIGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ListZoneAuthResponse
func (a *ZoneAuthAPIService) GetExecute(r ZoneAuthAPIGetRequest) (*ListZoneAuthResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *ListZoneAuthResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "ZoneAuthAPIService.Get")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/zone_auth"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.returnFields != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_return_fields", r.returnFields, "form", "")
	}
	if r.returnFields2 != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_return_fields+", r.returnFields2, "form", "")
	}
	if r.maxResults != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_max_results", r.maxResults, "form", "")
	}
	if r.returnAsObject != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_return_as_object", r.returnAsObject, "form", "")
	}
	if r.paging != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_paging", r.paging, "form", "")
	}
	if r.pageId != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_page_id", r.pageId, "form", "")
	}
	if r.filters != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "filters", r.filters, "form", "")
	}
	if r.extattrfilter != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "extattrfilter", r.extattrfilter, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type ZoneAuthAPIPostRequest struct {
	ctx            context.Context
	ApiService     ZoneAuthAPI
	zoneAuth       *ZoneAuth
	returnFields   *string
	returnFields2  *string
	returnAsObject *int32
}

// Object data to create
func (r ZoneAuthAPIPostRequest) ZoneAuth(zoneAuth ZoneAuth) ZoneAuthAPIPostRequest {
	r.zoneAuth = &zoneAuth
	return r
}

// Enter the field names followed by comma
func (r ZoneAuthAPIPostRequest) ReturnFields(returnFields string) ZoneAuthAPIPostRequest {
	r.returnFields = &returnFields
	return r
}

// Enter the field names followed by comma, this returns the required fields along with the default fields
func (r ZoneAuthAPIPostRequest) ReturnFields2(returnFields2 string) ZoneAuthAPIPostRequest {
	r.returnFields2 = &returnFields2
	return r
}

// Select 1 if result is required as an object
func (r ZoneAuthAPIPostRequest) ReturnAsObject(returnAsObject int32) ZoneAuthAPIPostRequest {
	r.returnAsObject = &returnAsObject
	return r
}

func (r ZoneAuthAPIPostRequest) Execute() (*CreateZoneAuthResponse, *http.Response, error) {
	return r.ApiService.PostExecute(r)
}

/*
Post Create a zone_auth object

Creates a new zone_auth object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ZoneAuthAPIPostRequest
*/
func (a *ZoneAuthAPIService) Post(ctx context.Context) ZoneAuthAPIPostRequest {
	return ZoneAuthAPIPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CreateZoneAuthResponse
func (a *ZoneAuthAPIService) PostExecute(r ZoneAuthAPIPostRequest) (*CreateZoneAuthResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *CreateZoneAuthResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "ZoneAuthAPIService.Post")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/zone_auth"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.zoneAuth == nil {
		return localVarReturnValue, nil, internal.ReportError("zoneAuth is required and must be specified")
	}

	if r.returnFields != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_return_fields", r.returnFields, "form", "")
	}
	if r.returnFields2 != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_return_fields+", r.returnFields2, "form", "")
	}
	if r.returnAsObject != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_return_as_object", r.returnAsObject, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if len(a.Client.Cfg.DefaultExtAttrs) > 0 && r.zoneAuth != nil {
		if r.zoneAuth.Extattrs == nil {
			r.zoneAuth.Extattrs = &map[string]ExtAttrs{}
		}
		for k, v := range a.Client.Cfg.DefaultExtAttrs {
			if _, ok := (*r.zoneAuth.Extattrs)[k]; !ok {
				(*r.zoneAuth.Extattrs)[k] = ExtAttrs{
					Value: v.Value,
				}
			}
		}
	}
	// body params
	localVarPostBody = r.zoneAuth
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type ZoneAuthAPIReferenceDeleteRequest struct {
	ctx            context.Context
	ApiService     ZoneAuthAPI
	reference      string
	removeSubzones *bool
}

// Remove subzones delete option. Determines whether all child objects should be removed alongside with the parent zone or child objects should be assigned to another parental zone. By default child objects are deleted with the parent zone.
func (r ZoneAuthAPIReferenceDeleteRequest) RemoveSubzones(removeSubzones bool) ZoneAuthAPIReferenceDeleteRequest {
	r.removeSubzones = &removeSubzones
	return r
}

func (r ZoneAuthAPIReferenceDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ReferenceDeleteExecute(r)
}

/*
ReferenceDelete Delete a zone_auth object

Deletes a specific zone_auth object by reference

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param reference Reference of the zone_auth object
	@return ZoneAuthAPIReferenceDeleteRequest
*/
func (a *ZoneAuthAPIService) ReferenceDelete(ctx context.Context, reference string) ZoneAuthAPIReferenceDeleteRequest {
	return ZoneAuthAPIReferenceDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		reference:  reference,
	}
}

// Execute executes the request
func (a *ZoneAuthAPIService) ReferenceDeleteExecute(r ZoneAuthAPIReferenceDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []internal.FormFile
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "ZoneAuthAPIService.ReferenceDelete")
	if err != nil {
		return nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/zone_auth/{reference}"
	localVarPath = strings.Replace(localVarPath, "{"+"reference"+"}", url.PathEscape(internal.ParameterValueToString(r.reference, "reference")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.removeSubzones != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "remove_subzones", r.removeSubzones, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ZoneAuthAPIReferenceGetRequest struct {
	ctx            context.Context
	ApiService     ZoneAuthAPI
	reference      string
	returnFields   *string
	returnFields2  *string
	returnAsObject *int32
}

// Enter the field names followed by comma
func (r ZoneAuthAPIReferenceGetRequest) ReturnFields(returnFields string) ZoneAuthAPIReferenceGetRequest {
	r.returnFields = &returnFields
	return r
}

// Enter the field names followed by comma, this returns the required fields along with the default fields
func (r ZoneAuthAPIReferenceGetRequest) ReturnFields2(returnFields2 string) ZoneAuthAPIReferenceGetRequest {
	r.returnFields2 = &returnFields2
	return r
}

// Select 1 if result is required as an object
func (r ZoneAuthAPIReferenceGetRequest) ReturnAsObject(returnAsObject int32) ZoneAuthAPIReferenceGetRequest {
	r.returnAsObject = &returnAsObject
	return r
}

func (r ZoneAuthAPIReferenceGetRequest) Execute() (*GetZoneAuthResponse, *http.Response, error) {
	return r.ApiService.ReferenceGetExecute(r)
}

/*
ReferenceGet Get a specific zone_auth object

Returns a specific zone_auth object by reference

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param reference Reference of the zone_auth object
	@return ZoneAuthAPIReferenceGetRequest
*/
func (a *ZoneAuthAPIService) ReferenceGet(ctx context.Context, reference string) ZoneAuthAPIReferenceGetRequest {
	return ZoneAuthAPIReferenceGetRequest{
		ApiService: a,
		ctx:        ctx,
		reference:  reference,
	}
}

// Execute executes the request
//
//	@return GetZoneAuthResponse
func (a *ZoneAuthAPIService) ReferenceGetExecute(r ZoneAuthAPIReferenceGetRequest) (*GetZoneAuthResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *GetZoneAuthResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "ZoneAuthAPIService.ReferenceGet")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/zone_auth/{reference}"
	localVarPath = strings.Replace(localVarPath, "{"+"reference"+"}", url.PathEscape(internal.ParameterValueToString(r.reference, "reference")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.returnFields != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_return_fields", r.returnFields, "form", "")
	}
	if r.returnFields2 != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_return_fields+", r.returnFields2, "form", "")
	}
	if r.returnAsObject != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_return_as_object", r.returnAsObject, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type ZoneAuthAPIReferencePutRequest struct {
	ctx            context.Context
	ApiService     ZoneAuthAPI
	reference      string
	zoneAuth       *ZoneAuth
	returnFields   *string
	returnFields2  *string
	returnAsObject *int32
}

// Object data to update
func (r ZoneAuthAPIReferencePutRequest) ZoneAuth(zoneAuth ZoneAuth) ZoneAuthAPIReferencePutRequest {
	r.zoneAuth = &zoneAuth
	return r
}

// Enter the field names followed by comma
func (r ZoneAuthAPIReferencePutRequest) ReturnFields(returnFields string) ZoneAuthAPIReferencePutRequest {
	r.returnFields = &returnFields
	return r
}

// Enter the field names followed by comma, this returns the required fields along with the default fields
func (r ZoneAuthAPIReferencePutRequest) ReturnFields2(returnFields2 string) ZoneAuthAPIReferencePutRequest {
	r.returnFields2 = &returnFields2
	return r
}

// Select 1 if result is required as an object
func (r ZoneAuthAPIReferencePutRequest) ReturnAsObject(returnAsObject int32) ZoneAuthAPIReferencePutRequest {
	r.returnAsObject = &returnAsObject
	return r
}

func (r ZoneAuthAPIReferencePutRequest) Execute() (*UpdateZoneAuthResponse, *http.Response, error) {
	return r.ApiService.ReferencePutExecute(r)
}

/*
ReferencePut Update a zone_auth object

Updates a specific zone_auth object by reference

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param reference Reference of the zone_auth object
	@return ZoneAuthAPIReferencePutRequest
*/
func (a *ZoneAuthAPIService) ReferencePut(ctx context.Context, reference string) ZoneAuthAPIReferencePutRequest {
	return ZoneAuthAPIReferencePutRequest{
		ApiService: a,
		ctx:        ctx,
		reference:  reference,
	}
}

// Execute executes the request
//
//	@return UpdateZoneAuthResponse
func (a *ZoneAuthAPIService) ReferencePutExecute(r ZoneAuthAPIReferencePutRequest) (*UpdateZoneAuthResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *UpdateZoneAuthResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "ZoneAuthAPIService.ReferencePut")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/zone_auth/{reference}"
	localVarPath = strings.Replace(localVarPath, "{"+"reference"+"}", url.PathEscape(internal.ParameterValueToString(r.reference, "reference")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.zoneAuth == nil {
		return localVarReturnValue, nil, internal.ReportError("zoneAuth is required and must be specified")
	}

	if r.returnFields != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_return_fields", r.returnFields, "form", "")
	}
	if r.returnFields2 != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_return_fields+", r.returnFields2, "form", "")
	}
	if r.returnAsObject != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_return_as_object", r.returnAsObject, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if len(a.Client.Cfg.DefaultExtAttrs) > 0 && r.zoneAuth != nil {
		if r.zoneAuth.Extattrs == nil {
			r.zoneAuth.Extattrs = &map[string]ExtAttrs{}
		}
		for k, v := range a.Client.Cfg.DefaultExtAttrs {
			if _, ok := (*r.zoneAuth.Extattrs)[k]; !ok {
				(*r.zoneAuth.Extattrs)[k] = ExtAttrs{
					Value: v.Value,
				}
			}
		}
	}
	// body params
	localVarPostBody = r.zoneAuth
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}
